#!/usr/bin/env node
console.log('----------------------------------\nRFCX | ./bin/start_mqtt started')

console.log(new String(require('child_process').execSync(process.cwd() + '/bin/setup')))

var appId = 'rfcx-api-mqtt'

var debug = require('debug')(appId)
var app = require('../app-mqtt.js')
var models = require('../models')
const guidService = require('../utils/misc/guid.js')

console.log('RFCX | Starting server')

var httpServer = app.http.listen(app.http.get('port'), function () {
  console.log('http: ' + app.http.get('title') + ' (port ' + app.http.get('port') + ') (' + process.env.NODE_ENV + ')')
})

const subscriptionOptions = {
  qos: 2
}

const checkinsTopicName = 'grd/+/chk'
const pingsTopicName = 'grd/+/png'

app.mqtt.on('connect', function () {
  console.log('mqtt: ' + appId + ' (' + app.mqtt.options.protocol + '://' + app.mqtt.options.host + ':' + app.mqtt.options.port + ') (' + process.env.NODE_ENV + ')')
  app.mqtt.unsubscribe(checkinsTopicName, (err) => {
    if (err) {
      console.log(`mqtt: could not unsubscribe from topic "${checkinsTopicName}"`, err)
      return
    }
    console.log(`mqtt: unsubscribed from topic "${checkinsTopicName}"`)
    app.mqtt.subscribe(checkinsTopicName, subscriptionOptions, (err, granted) => {
      if (err) {
        console.log(`mqtt: could not subscribe to topic "${checkinsTopicName}"`, err)
        return
      }
      console.log(`mqtt: subscribed to topic "${checkinsTopicName}"`, granted)
    })
  })
  app.mqtt.unsubscribe(pingsTopicName, (err) => {
    if (err) {
      console.log(`mqtt: could not unsubscribe from topic "${pingsTopicName}"`, err)
      return
    }
    console.log(`mqtt: unsubscribed from topic "${pingsTopicName}"`)
    app.mqtt.subscribe(pingsTopicName, subscriptionOptions, (err, granted) => {
      if (err) {
        console.log(`mqtt: could not subscribe to topic "${pingsTopicName}"`, err)
        return
      }
      console.log(`mqtt: subscribed to topic "${pingsTopicName}"`, granted)
    })
  })
})

app.mqtt.on('error', (err) => {
  console.log('mqtt: Error', err)
})

app.mqtt.on('reconnect', () => {
  console.log('mqtt: Reconnected.')
})
app.mqtt.on('close', () => {
  console.log('mqtt: Closed.')
})

if (process && process.pid) {
  console.log('pid', process.pid)
}

var mqttCheckInRouter = require('../utils/rfcx-mqtt/mqtt-checkin-router.js').mqttCheckInRouter
var pingRouter = require('../utils/rfcx-guardian/router-ping.js').pingRouter

app.mqtt.on('message', (topic, data) => {
  let messageId = guidService.generate()
  console.log('new mqtt message', topic, messageId)

  if (/grd\/.+\/chk/.test(topic)) {
    return mqttCheckInRouter.onMessageCheckin(data, messageId)
      .then((result) => {
        app.mqtt.publish(`grd/${result.guardian_guid}/cmd`, result.gzip)

      // THE FOLLOWING "publish" LINE IS INCLUDED TO SUPPORT GUARDIANS DEPLOYED PRIOR TO Q2, 2020
      // AFTER ALL Q2 2020 GUARDIANS HAVE EXPIRED, THE LINE BELOW SHOULD BE REMOVED
        app.mqtt.publish(`guardians/${result.guardian_guid}/guardian/checkins`, result.gzip)
      // AFTER ALL Q2 2020 GUARDIANS HAVE EXPIRED, THE LINE ABOVE SHOULD BE REMOVED

        console.log('mqtt message processed', topic, messageId)
        messageId = null
        result = null
        return true
      })
      .catch((err) => {
        if (typeof (err) === 'string') {
          err = { message: err }
        }
        console.error('mqtt message error', err)
      })
  } else if (/grd\/.+\/png/.test(topic)) {
    return pingRouter.onMqttMessagePing(data, messageId)
      .then((result) => {
        if (Object.keys(result.obj).length > 0) {
          app.mqtt.publish(`grd/${result.guardian_guid}/cmd`, result.gzip)
        }

        console.log('mqtt message processed', topic, messageId)
        messageId = null
        result = null
        return true
      })
      .catch((err) => {
        if (typeof (err) === 'string') {
          err = { message: err }
        }
        console.error('mqtt message error', err)
      })
  }
})
