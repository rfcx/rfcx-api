#!/usr/bin/env node
console.log('----------------------------------\nRFCX | ./bin/start_mqtt started')

console.log(new String(require("child_process").execSync(process.cwd()+"/bin/setup")));

var appId = "rfcx-api-mqtt";

var debug = require("debug")(appId);
var app = require("../app-mqtt.js");
var models = require("../models");
const guidService = require('../utils/misc/guid.js');

const loggers = require('../utils/logger');
const logDebug = loggers.debugLogger.log;
const logError = loggers.errorLogger.log;

console.log('RFCX | Starting server');

var httpServer = app.http.listen(app.http.get('port'), function(){
  console.log("http: "+app.http.get("title")+" (port "+app.http.get('port')+") ("+process.env.NODE_ENV+")");
});

app.mqtt.on("connect", function(){
  console.log("mqtt: "+appId+" ("+app.mqtt.options.protocol+"://"+app.mqtt.options.host+":"+app.mqtt.options.port+") ("+process.env.NODE_ENV+")");
  app.mqtt.unsubscribe("guardians/checkins", (err) => {
    if (err) {
      console.log('mqtt: could not unsubscribe from topic "guardians/checkins"', err);
      return;
    }
    console.log('mqtt: unsubscribed from topic "guardians/checkins"');
    app.mqtt.subscribe("guardians/checkins", (err, granted) => {
      if (err) {
        console.log('mqtt: could not subscribe to topic "guardians/checkins"', err);
        return;
      }
      console.log('mqtt: subscribed to topic "guardians/checkins"', granted);
    });
  });
});

app.mqtt.on("error", (err) => {
  console.log("mqtt: Error", err);
});

app.mqtt.on('reconnect', () => {
  console.log('mqtt: Reconnected.');
})
app.mqtt.on('close', () => {
  console.log('mqtt: Closed.');
})


// var mqttInstructions = require("../utils/rfcx-mqtt/mqtt-instructions.js").mqttInstructions;
// var mqttPublish = require("../utils/rfcx-mqtt/mqtt-publish.js").mqttPublish;

// mqttInstructions.setupInstructionAction( checkInObj.db.dbGuardian, "guardian" ).then(function(instructionObj){
//   mqttPublish.processAndCompressPublishJson(instructionObj).then(function(instructionObj){

//     app.mqtt.publish(instructionObj.mqtt.topic, instructionObj.rtrn.gzip);
//     console.log(JSON.stringify(instructionObj.rtrn.obj));

//   }).catch(function(errProcessInstructionJson){ console.log(errProcessInstructionJson); reject(new Error(errProcessInstructionJson)); });
// }).catch(function(errSetupInstructionAction){ console.log(errSetupInstructionAction); });

if (process && process.pid) {
  console.log('pid', process.pid);
}

var mqttCheckInRouter = require("../utils/rfcx-mqtt/mqtt-checkin-router.js").mqttCheckInRouter;

app.mqtt.on("message", (topic, data) => {
  let messageId = guidService.generate();
  logDebug('new mqtt message', { topic });
  if (topic === "guardians/checkins") {
    logDebug('mqtt message', { topic });

    return mqttCheckInRouter.onMessageCheckin(data, messageId)
      .then((result) => {
        logDebug('mqtt message return object', {
          guardian_guid: result.guardian_guid,
          gzip: result.gzip
        });
        app.mqtt.publish(`guardians/${result.guardian_guid}/guardian/checkins`, result.gzip);
        messageId = null;
        result = null;
        return true;
      })
      .catch((err) => {
        // TODO: We need to send a report back to guardian with error information here
        logDebug('mqtt message return object', err);
        logError('mqtt message error', { err });
      });
  }
});


